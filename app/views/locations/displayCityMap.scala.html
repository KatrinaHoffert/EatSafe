@import general._
@import models._
@import controllers._
@import util.TypeConversions

@**
 * Displays the multi-map.
 *
 * @param city The name of the city to center the map over, initially.
 * @param locations All locations to be plotted. These don't have to be complete locations. They
 * merely must have the coordinates and location.
 *@
@(city: String, locations: Seq[Location])

@scripts = {
  <script src="https://maps.googleapis.com/maps/api/js?v=3.exp&signed_in=true"></script>
  <script>
    /**
     * Maximum number of nearby locations listed.
     */
    var MAX_NEARBY = 8;

    /**
     * Miniumum accuracy of geo-positioning in order to have nearby locations, in meters. If the
     * location system is too inaccurate, the nearby locations will be too inaccurate.
     */
    var MIN_ACCURACY_FOR_NEARBY = 2000;

    /**
     * Default zoom level of the map and when being taken to a location. In Google Maps API's units.
     */
    var DEFAULT_ZOOM = 15;

    /**
     * Viewport width at which below this, the sidebar opens closed and automatically closes when a
     * location is selected. This should be kept consistent with the sidebar CSS.
     */
    var SIDEBAR_AUTOCLOSE_WIDTH = 950;

    var locations = @Html(TypeConversions.locationsToMultiMapJson(locations).toString);

    function sizeMapCanvas() {
      // Set the map container size to fill the remaining space
      var canvas = $("#map-canvas");
      var canvasHeight = $(window).height() - canvas.offset().top;
      canvas.css("height", canvasHeight + "px");
      canvas.css("width", "100%");
    }

    $(window).resize(sizeMapCanvas);
    sizeMapCanvas();

    // Create the map
    var geocoder;
    var map;

    function initialize() {
      geocoder = new google.maps.Geocoder();
      var latlng = new google.maps.LatLng(52.1333, -106.6833);
      map = new google.maps.Map(document.getElementById("map-canvas"), {
        zoom: 3,
        center: latlng
      });
      codeAddress();
    }
    google.maps.event.addDomListener(window, 'load', initialize);

    // Retain center when resizing map. Otherwise the resizing will retain the top left corner and
    // we may end up hiding the marker from view, which is probably in the center of the window
    // (although it doesn't have to be and this doesn't depend on the marker position). This
    // helps ensure that resizing the map still looks at the same thing (assuming the thing is
    // in fact in the center).
    google.maps.event.addDomListener(window, "resize", function() {
      if(map != null) {
        var center = map.getCenter();
        google.maps.event.trigger(map, "resize");
        map.setCenter(center);
      }
    });

    /**
     * Takes the address and city passed into this view and geocodes their location.
     */
    function codeAddress() {
      var address = "@{city}, Saskatchewan";
      geocoder.geocode( { "address": address }, function(results, status) {
        if(status == google.maps.GeocoderStatus.OK) {
          map.setCenter(results[0].geometry.location);
          map.setZoom(DEFAULT_ZOOM);
        }
        else {
          alert("Geocoding failed: " + status);
        }
      });
    }

    /** Extend Number object with method to convert numeric degrees to radians */
    if (typeof Number.prototype.toRadians == 'undefined') {
      Number.prototype.toRadians = function() { return this * Math.PI / 180; };
    }

    /**
     * Calculates distances between two coordinates.
     * 
     * Uses code from <http://www.movable-type.co.uk/scripts/latlong.html>
     *
     * @@return Distance between the two points in meters.
     */
    function calculateDistances(lat1, long1, lat2, long2) {
        var R = 6371; // km
        var φ1 = lat1.toRadians();
        var φ2 = lat2.toRadians();
        var Δφ = (lat2-lat1).toRadians();
        var Δλ = (long2-long1).toRadians();
        
        var a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ/2) * Math.sin(Δλ/2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        var d = R * c;
        
        return d;
    }

    /**
     * Formats a distance in meters as one in kilometers, with rounding.
     *
     * @@return meters rounded to 2 decimal places, in kilometers.
     */
    function roundTo2DecimalPlaces(num) {
      return Math.round(num * 100) / 100;
    }

    /**
     * Populates the list of nearby locations with a list of anchors that, when clicked, scroll the
     * map to the coordinates of the location with the default zoom level.
     */
    function populateNearbyList() {
      if("geolocation" in navigator) {
        navigator.geolocation.getCurrentPosition(function(position) {
          if(position.coords.accuracy <= MIN_ACCURACY_FOR_NEARBY) {
            var userLatitude = position.coords.latitude;
            var userLongitude = position.coords.longitude;
            console.log("User coords: " + userLatitude + ", " + userLongitude);

            var locationsWithDistance = locations.map(function(location, index, array) {
              location.distanceFromUser = calculateDistances(userLatitude, userLongitude,
                  location.latitude, location.longitude);
              return location;
            });
            var closestLocations = locationsWithDistance.sort(function(loc1, loc2) {
              return loc1.distanceFromUser - loc2.distanceFromUser;
            }).slice(0, MAX_NEARBY);

            // Goddamn does JS need some more succient FP. In Scala, this would be a much more
            // readable: `closestLocations.map(_.distanceFromUser)`
            console.log("Distances of closest locations: " +
                JSON.stringify(closestLocations.map(function(l){ return l.distanceFromUser; })));
            console.log("Coordinates of them: " +
                JSON.stringify(closestLocations.map(function(l){ return "(" + l.latitude +
                ", " + l.longitude + ")"; })));

            var sidebarHtml = closestLocations.map(function(location, index, array) {
              return "<li>" +
                  "<a data-latitude='" + location.latitude +"' data-longitude='" + location.longitude +
                  "' href='#'>" + location.name + "<br />" + roundTo2DecimalPlaces(location.distanceFromUser) +
                  " @Messages("maps.multiMap.kmAway")</a>" +
                  "</li>";
            });

            $("#nearbyList").html(sidebarHtml.join("\n"));

            $("#nearbyList a").on("click", function(event) {
              var latitude = $(event.target).attr("data-latitude");
              var longitude = $(event.target).attr("data-longitude");
              goToCoords(latitude, longitude, true);
            });
          }
          else {
            $("#nearbyList a").html("@Messages("maps.multiMap.locationInaccurate")");
          }
        },
        // Callback for an error in getting user position
        function() {
          $("#nearbyList a").html("@Messages("maps.multiMap.locationFailed")");
        });
      }
      else {
        $("#nearbyList a").html("@Messages("maps.multiMap.locationNotSupported")");
      }
    }
    populateNearbyList();

    // Toggles display of the sidebar
    $("#menu-toggle").on("click", function(e) {
      e.preventDefault();
      $("#wrapper").toggleClass("toggled");
    });

    // Moves the map to the user's coordinates
    $("#moveToMe").on("click", function() {
      if("geolocation" in navigator) {
        navigator.geolocation.getCurrentPosition(function(position) {
          if(position.coords.accuracy <= MIN_ACCURACY_FOR_NEARBY) {
            goToCoords(position.coords.latitude, position.coords.longitude, false);
          }
          else {
            alert("@Messages("maps.multiMap.moveToMeInaccurate")")
          }
        },
        function() {
          alert("@Messages("maps.multiMap.moveToMeFailed")")
        });
      }
      else {
        alert("@Messages("maps.multiMap.moveToMeUnsupported")")
      }
    });

    /**
     * Scrolls the map to a new location and resets the zoom. If the viewport width is such that
     * the sidebar is defaultly closed, we close the sidebar on selecting a location.
     *
     * @@param toggle If true, toggles the sidebar (which will close it if it's open).
     */
    function goToCoords(lat, long, toggle) {
      map.setCenter(new google.maps.LatLng(lat, long));
      map.setZoom(DEFAULT_ZOOM);

      if(toggle && $(window).width() < SIDEBAR_AUTOCLOSE_WIDTH) {
         $("#wrapper").toggleClass("toggled");
      }
    }
  </script>
}

@mainBody(title = Messages("maps.multiMap.title"), moreScripts = scripts) {
<link rel="stylesheet" href="@controllers.routes.Assets.at("stylesheets/simple-sidebar.css")" />
<div id="wrapper">
  <div id="sidebar-wrapper">
    <ul class="sidebar-nav">
      <h2 class="nearbyHeading">@Messages("maps.multiMap.nearbyLocationsHeading")</h2>
      <div id="nearbyList">
        <li>
          <a href="#">@Messages("maps.multiMap.sidebarLoading")</a>
        </li>
      </div>
    </ul>
  </div>
  <div id="page-content-wrapper">
    @headingSmall(Messages("general.applicationName"))
    <a href="#menu-toggle" class="btn btn-default" id="menu-toggle">
      <span class="glyphicon glyphicon-map-marker" aria-hidden="true"></span>
      @Messages("maps.multiMap.nearbyLocationsToggle")
    </a>
    <button class="btn btn-default" id="moveToMe">
      @Messages("maps.multiMap.findMe")
    </button>
    <div id="map-canvas"></div>
  </div>
</div>
  
}